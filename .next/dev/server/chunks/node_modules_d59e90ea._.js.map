{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/dotenv/package.json"],"sourcesContent":["{\"name\":\"dotenv\",\"version\":\"17.2.3\",\"description\":\"Loads environment variables from .env file\",\"main\":\"lib/main.js\",\"types\":\"lib/main.d.ts\",\"exports\":{\".\":{\"types\":\"./lib/main.d.ts\",\"require\":\"./lib/main.js\",\"default\":\"./lib/main.js\"},\"./config\":\"./config.js\",\"./config.js\":\"./config.js\",\"./lib/env-options\":\"./lib/env-options.js\",\"./lib/env-options.js\":\"./lib/env-options.js\",\"./lib/cli-options\":\"./lib/cli-options.js\",\"./lib/cli-options.js\":\"./lib/cli-options.js\",\"./package.json\":\"./package.json\"},\"scripts\":{\"dts-check\":\"tsc --project tests/types/tsconfig.json\",\"lint\":\"standard\",\"pretest\":\"npm run lint && npm run dts-check\",\"test\":\"tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000\",\"test:coverage\":\"tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov\",\"prerelease\":\"npm test\",\"release\":\"standard-version\"},\"repository\":{\"type\":\"git\",\"url\":\"git://github.com/motdotla/dotenv.git\"},\"homepage\":\"https://github.com/motdotla/dotenv#readme\",\"funding\":\"https://dotenvx.com\",\"keywords\":[\"dotenv\",\"env\",\".env\",\"environment\",\"variables\",\"config\",\"settings\"],\"readmeFilename\":\"README.md\",\"license\":\"BSD-2-Clause\",\"devDependencies\":{\"@types/node\":\"^18.11.3\",\"decache\":\"^4.6.2\",\"sinon\":\"^14.0.1\",\"standard\":\"^17.0.0\",\"standard-version\":\"^9.5.0\",\"tap\":\"^19.2.0\",\"typescript\":\"^4.8.4\"},\"engines\":{\"node\":\">=12\"},\"browser\":{\"fs\":false}}"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 3, "column": 1435}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jose/.gemini/antigravity/scratch/ai-woo-uploader/node_modules/dotenv/lib/main.js"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\n// Array of tips to display randomly\nconst TIPS = [\n  'üîê encrypt with Dotenvx: https://dotenvx.com',\n  'üîê prevent committing .env to code: https://dotenvx.com/precommit',\n  'üîê prevent building .env in docker: https://dotenvx.com/prebuild',\n  'üì° add observability to secrets: https://dotenvx.com/ops',\n  'üë• sync secrets across teammates & machines: https://dotenvx.com/ops',\n  'üóÇÔ∏è backup and recover secrets: https://dotenvx.com/ops',\n  '‚úÖ audit secrets and track compliance: https://dotenvx.com/ops',\n  'üîÑ add secrets lifecycle management: https://dotenvx.com/ops',\n  'üîë add access controls to secrets: https://dotenvx.com/ops',\n  'üõ†Ô∏è  run anywhere with `dotenvx run -- yourcommand`',\n  '‚öôÔ∏è  specify custom .env file path with { path: \\'/custom/path/.env\\' }',\n  '‚öôÔ∏è  enable debug logging with { debug: true }',\n  '‚öôÔ∏è  override existing env vars with { override: true }',\n  '‚öôÔ∏è  suppress all logs with { quiet: true }',\n  '‚öôÔ∏è  write to custom object with { processEnv: myObject }',\n  '‚öôÔ∏è  load multiple .env files with { path: [\\'.env.local\\', \\'.env\\'] }'\n]\n\n// Get a random tip from the tips array\nfunction _getRandomTip () {\n  return TIPS[Math.floor(Math.random() * TIPS.length)]\n}\n\nfunction parseBoolean (value) {\n  if (typeof value === 'string') {\n    return !['false', '0', 'no', 'off', ''].includes(value.toLowerCase())\n  }\n  return Boolean(value)\n}\n\nfunction supportsAnsi () {\n  return process.stdout.isTTY // && process.env.TERM !== 'dumb'\n}\n\nfunction dim (text) {\n  return supportsAnsi() ? `\\x1b[2m${text}\\x1b[0m` : text\n}\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  options = options || {}\n\n  const vaultPath = _vaultPath(options)\n  options.path = vaultPath // parse .env.vault\n  const result = DotenvModule.configDotenv(options)\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.error(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n  let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  const populated = DotenvModule.populate(processEnv, parsedAll, options)\n\n  // handle user settings DOTENV_CONFIG_ options inside .env file(s)\n  debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug)\n  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet)\n\n  if (debug || !quiet) {\n    const keysCount = Object.keys(populated).length\n    const shortPaths = []\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath)\n        shortPaths.push(relative)\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`)\n        }\n        lastError = e\n      }\n    }\n\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`-- tip: ${_getRandomTip()}`)}`)\n  }\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n  const populated = {}\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n        populated[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n      populated[key] = parsed[key]\n    }\n  }\n\n  return populated\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jose/.gemini/antigravity/scratch/ai-woo-uploader/node_modules/csv-stringify/lib/utils/get.js"],"sourcesContent":["// Lodash implementation of `get`\n\nconst charCodeOfDot = \".\".charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  \"[^.[\\\\]]+\" +\n    \"|\" +\n    // Or match property names within brackets.\n    \"\\\\[(?:\" +\n    // Match a non-string expression.\n    \"([^\\\"'][^[]*)\" +\n    \"|\" +\n    // Or match strings (supports escaping characters).\n    \"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" +\n    \")\\\\]\" +\n    \"|\" +\n    // Or match \"\" as the space between consecutive dots or empty brackets.\n    \"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\",\n  \"g\",\n);\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst getTag = function (value) {\n  // if (!value) value === undefined ? \"[object Undefined]\" : \"[object Null]\";\n  return Object.prototype.toString.call(value);\n};\n\nconst isSymbol = function (value) {\n  const type = typeof value;\n  return (\n    type === \"symbol\" ||\n    (type === \"object\" && value && getTag(value) === \"[object Symbol]\")\n  );\n};\n\nconst isKey = function (value, object) {\n  if (Array.isArray(value)) {\n    return false;\n  }\n  const type = typeof value;\n  if (\n    type === \"number\" ||\n    type === \"symbol\" ||\n    type === \"boolean\" ||\n    !value ||\n    isSymbol(value)\n  ) {\n    return true;\n  }\n  return (\n    reIsPlainProp.test(value) ||\n    !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object))\n  );\n};\n\nconst stringToPath = function (string) {\n  const result = [];\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push(\"\");\n  }\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    let key = match;\n    if (quote) {\n      key = subString.replace(reEscapeChar, \"$1\");\n    } else if (expression) {\n      key = expression.trim();\n    }\n    result.push(key);\n  });\n  return result;\n};\n\nconst castPath = function (value, object) {\n  if (Array.isArray(value)) {\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\n\nconst toKey = function (value) {\n  if (typeof value === \"string\" || isSymbol(value)) return value;\n  const result = `${value}`;\n  // eslint-disable-next-line\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n};\n\nconst get = function (object, path) {\n  path = castPath(path, object);\n  let index = 0;\n  const length = path.length;\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return index && index === length ? object : undefined;\n};\n\nexport { get };\n"],"names":[],"mappings":"AAAA,iCAAiC;;;;;AAEjC,MAAM,gBAAgB,IAAI,UAAU,CAAC;AACrC,MAAM,eAAe;AACrB,MAAM,aAAa,OACjB,8CAA8C;AAC9C,cACE,MACA,2CAA2C;AAC3C,WACA,iCAAiC;AACjC,kBACA,MACA,mDAAmD;AACnD,2CACA,SACA,MACA,uEAAuE;AACvE,sCACF;AAEF,MAAM,eAAe;AACrB,MAAM,gBAAgB;AAEtB,MAAM,SAAS,SAAU,KAAK;IAC5B,4EAA4E;IAC5E,OAAO,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC;AACxC;AAEA,MAAM,WAAW,SAAU,KAAK;IAC9B,MAAM,OAAO,OAAO;IACpB,OACE,SAAS,YACR,SAAS,YAAY,SAAS,OAAO,WAAW;AAErD;AAEA,MAAM,QAAQ,SAAU,KAAK,EAAE,MAAM;IACnC,IAAI,MAAM,OAAO,CAAC,QAAQ;QACxB,OAAO;IACT;IACA,MAAM,OAAO,OAAO;IACpB,IACE,SAAS,YACT,SAAS,YACT,SAAS,aACT,CAAC,SACD,SAAS,QACT;QACA,OAAO;IACT;IACA,OACE,cAAc,IAAI,CAAC,UACnB,CAAC,aAAa,IAAI,CAAC,UAClB,UAAU,QAAQ,SAAS,OAAO;AAEvC;AAEA,MAAM,eAAe,SAAU,MAAM;IACnC,MAAM,SAAS,EAAE;IACjB,IAAI,OAAO,UAAU,CAAC,OAAO,eAAe;QAC1C,OAAO,IAAI,CAAC;IACd;IACA,OAAO,OAAO,CAAC,YAAY,SAAU,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,SAAS;QACtE,IAAI,MAAM;QACV,IAAI,OAAO;YACT,MAAM,UAAU,OAAO,CAAC,cAAc;QACxC,OAAO,IAAI,YAAY;YACrB,MAAM,WAAW,IAAI;QACvB;QACA,OAAO,IAAI,CAAC;IACd;IACA,OAAO;AACT;AAEA,MAAM,WAAW,SAAU,KAAK,EAAE,MAAM;IACtC,IAAI,MAAM,OAAO,CAAC,QAAQ;QACxB,OAAO;IACT,OAAO;QACL,OAAO,MAAM,OAAO,UAAU;YAAC;SAAM,GAAG,aAAa;IACvD;AACF;AAEA,MAAM,QAAQ,SAAU,KAAK;IAC3B,IAAI,OAAO,UAAU,YAAY,SAAS,QAAQ,OAAO;IACzD,MAAM,SAAS,GAAG,OAAO;IACzB,2BAA2B;IAC3B,OAAO,UAAU,OAAO,IAAI,SAAS,CAAC,WAAW,OAAO;AAC1D;AAEA,MAAM,MAAM,SAAU,MAAM,EAAE,IAAI;IAChC,OAAO,SAAS,MAAM;IACtB,IAAI,QAAQ;IACZ,MAAM,SAAS,KAAK,MAAM;IAC1B,MAAO,UAAU,QAAQ,QAAQ,OAAQ;QACvC,SAAS,MAAM,CAAC,MAAM,IAAI,CAAC,QAAQ,EAAE;IACvC;IACA,OAAO,SAAS,UAAU,SAAS,SAAS;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 471, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jose/.gemini/antigravity/scratch/ai-woo-uploader/node_modules/csv-stringify/lib/utils/is_object.js"],"sourcesContent":["const is_object = function (obj) {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n};\n\nexport { is_object };\n"],"names":[],"mappings":";;;;AAAA,MAAM,YAAY,SAAU,GAAG;IAC7B,OAAO,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,MAAM,OAAO,CAAC;AACnE","ignoreList":[0]}},
    {"offset": {"line": 483, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jose/.gemini/antigravity/scratch/ai-woo-uploader/node_modules/csv-stringify/lib/api/normalize_columns.js"],"sourcesContent":["const normalize_columns = function (columns) {\n  if (columns === undefined || columns === null) {\n    return [undefined, undefined];\n  }\n  if (typeof columns !== \"object\") {\n    return [Error('Invalid option \"columns\": expect an array or an object')];\n  }\n  if (!Array.isArray(columns)) {\n    const newcolumns = [];\n    for (const k in columns) {\n      newcolumns.push({\n        key: k,\n        header: columns[k],\n      });\n    }\n    columns = newcolumns;\n  } else {\n    const newcolumns = [];\n    for (const column of columns) {\n      if (typeof column === \"string\") {\n        newcolumns.push({\n          key: column,\n          header: column,\n        });\n      } else if (\n        typeof column === \"object\" &&\n        column !== null &&\n        !Array.isArray(column)\n      ) {\n        if (!column.key) {\n          return [\n            Error('Invalid column definition: property \"key\" is required'),\n          ];\n        }\n        if (column.header === undefined) {\n          column.header = column.key;\n        }\n        newcolumns.push(column);\n      } else {\n        return [\n          Error(\"Invalid column definition: expect a string or an object\"),\n        ];\n      }\n    }\n    columns = newcolumns;\n  }\n  return [undefined, columns];\n};\n\nexport { normalize_columns };\n"],"names":[],"mappings":";;;;AAAA,MAAM,oBAAoB,SAAU,OAAO;IACzC,IAAI,YAAY,aAAa,YAAY,MAAM;QAC7C,OAAO;YAAC;YAAW;SAAU;IAC/B;IACA,IAAI,OAAO,YAAY,UAAU;QAC/B,OAAO;YAAC,MAAM;SAA0D;IAC1E;IACA,IAAI,CAAC,MAAM,OAAO,CAAC,UAAU;QAC3B,MAAM,aAAa,EAAE;QACrB,IAAK,MAAM,KAAK,QAAS;YACvB,WAAW,IAAI,CAAC;gBACd,KAAK;gBACL,QAAQ,OAAO,CAAC,EAAE;YACpB;QACF;QACA,UAAU;IACZ,OAAO;QACL,MAAM,aAAa,EAAE;QACrB,KAAK,MAAM,UAAU,QAAS;YAC5B,IAAI,OAAO,WAAW,UAAU;gBAC9B,WAAW,IAAI,CAAC;oBACd,KAAK;oBACL,QAAQ;gBACV;YACF,OAAO,IACL,OAAO,WAAW,YAClB,WAAW,QACX,CAAC,MAAM,OAAO,CAAC,SACf;gBACA,IAAI,CAAC,OAAO,GAAG,EAAE;oBACf,OAAO;wBACL,MAAM;qBACP;gBACH;gBACA,IAAI,OAAO,MAAM,KAAK,WAAW;oBAC/B,OAAO,MAAM,GAAG,OAAO,GAAG;gBAC5B;gBACA,WAAW,IAAI,CAAC;YAClB,OAAO;gBACL,OAAO;oBACL,MAAM;iBACP;YACH;QACF;QACA,UAAU;IACZ;IACA,OAAO;QAAC;QAAW;KAAQ;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 544, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jose/.gemini/antigravity/scratch/ai-woo-uploader/node_modules/csv-stringify/lib/api/CsvError.js"],"sourcesContent":["class CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if (Array.isArray(message)) message = message.join(\" \");\n    super(message);\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value)\n          ? value.toString()\n          : value == null\n            ? value\n            : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\n\nexport { CsvError };\n"],"names":[],"mappings":";;;;AAAA,MAAM,iBAAiB;IACrB,YAAY,IAAI,EAAE,OAAO,EAAE,GAAG,QAAQ,CAAE;QACtC,IAAI,MAAM,OAAO,CAAC,UAAU,UAAU,QAAQ,IAAI,CAAC;QACnD,KAAK,CAAC;QACN,IAAI,MAAM,iBAAiB,KAAK,WAAW;YACzC,MAAM,iBAAiB,CAAC,IAAI,EAAE;QAChC;QACA,IAAI,CAAC,IAAI,GAAG;QACZ,KAAK,MAAM,WAAW,SAAU;YAC9B,IAAK,MAAM,OAAO,QAAS;gBACzB,MAAM,QAAQ,OAAO,CAAC,IAAI;gBAC1B,IAAI,CAAC,IAAI,GAAG,OAAO,QAAQ,CAAC,SACxB,MAAM,QAAQ,KACd,SAAS,OACP,QACA,KAAK,KAAK,CAAC,KAAK,SAAS,CAAC;YAClC;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 569, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jose/.gemini/antigravity/scratch/ai-woo-uploader/node_modules/csv-stringify/lib/utils/underscore.js"],"sourcesContent":["const underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return \"_\" + match.toLowerCase();\n  });\n};\n\nexport { underscore };\n"],"names":[],"mappings":";;;;AAAA,MAAM,aAAa,SAAU,GAAG;IAC9B,OAAO,IAAI,OAAO,CAAC,YAAY,SAAU,CAAC,EAAE,KAAK;QAC/C,OAAO,MAAM,MAAM,WAAW;IAChC;AACF","ignoreList":[0]}},
    {"offset": {"line": 583, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jose/.gemini/antigravity/scratch/ai-woo-uploader/node_modules/csv-stringify/lib/api/normalize_options.js"],"sourcesContent":["import { CsvError } from \"./CsvError.js\";\nimport { normalize_columns } from \"./normalize_columns.js\";\nimport { underscore } from \"../utils/underscore.js\";\n\nconst normalize_options = function (opts) {\n  const options = {};\n  // Merge with user options\n  for (const opt in opts) {\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `bom`\n  if (\n    options.bom === undefined ||\n    options.bom === null ||\n    options.bom === false\n  ) {\n    options.bom = false;\n  } else if (options.bom !== true) {\n    return [\n      new CsvError(\"CSV_OPTION_BOOLEAN_INVALID_TYPE\", [\n        \"option `bom` is optional and must be a boolean value,\",\n        `got ${JSON.stringify(options.bom)}`,\n      ]),\n    ];\n  }\n  // Normalize option `delimiter`\n  if (options.delimiter === undefined || options.delimiter === null) {\n    options.delimiter = \",\";\n  } else if (Buffer.isBuffer(options.delimiter)) {\n    options.delimiter = options.delimiter.toString();\n  } else if (typeof options.delimiter !== \"string\") {\n    return [\n      new CsvError(\"CSV_OPTION_DELIMITER_INVALID_TYPE\", [\n        \"option `delimiter` must be a buffer or a string,\",\n        `got ${JSON.stringify(options.delimiter)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quote`\n  if (options.quote === undefined || options.quote === null) {\n    options.quote = '\"';\n  } else if (options.quote === true) {\n    options.quote = '\"';\n  } else if (options.quote === false) {\n    options.quote = \"\";\n  } else if (Buffer.isBuffer(options.quote)) {\n    options.quote = options.quote.toString();\n  } else if (typeof options.quote !== \"string\") {\n    return [\n      new CsvError(\"CSV_OPTION_QUOTE_INVALID_TYPE\", [\n        \"option `quote` must be a boolean, a buffer or a string,\",\n        `got ${JSON.stringify(options.quote)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quoted`\n  if (options.quoted === undefined || options.quoted === null) {\n    options.quoted = false;\n  } else {\n    // todo\n  }\n  // Normalize option `escape_formulas`\n  if (\n    options.escape_formulas === undefined ||\n    options.escape_formulas === null\n  ) {\n    options.escape_formulas = false;\n  } else if (typeof options.escape_formulas !== \"boolean\") {\n    return [\n      new CsvError(\"CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE\", [\n        \"option `escape_formulas` must be a boolean,\",\n        `got ${JSON.stringify(options.escape_formulas)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quoted_empty`\n  if (options.quoted_empty === undefined || options.quoted_empty === null) {\n    options.quoted_empty = undefined;\n  } else {\n    // todo\n  }\n  // Normalize option `quoted_match`\n  if (\n    options.quoted_match === undefined ||\n    options.quoted_match === null ||\n    options.quoted_match === false\n  ) {\n    options.quoted_match = null;\n  } else if (!Array.isArray(options.quoted_match)) {\n    options.quoted_match = [options.quoted_match];\n  }\n  if (options.quoted_match) {\n    for (const quoted_match of options.quoted_match) {\n      const isString = typeof quoted_match === \"string\";\n      const isRegExp = quoted_match instanceof RegExp;\n      if (!isString && !isRegExp) {\n        return [\n          Error(\n            `Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`,\n          ),\n        ];\n      }\n    }\n  }\n  // Normalize option `quoted_string`\n  if (options.quoted_string === undefined || options.quoted_string === null) {\n    options.quoted_string = false;\n  } else {\n    // todo\n  }\n  // Normalize option `eof`\n  if (options.eof === undefined || options.eof === null) {\n    options.eof = true;\n  } else {\n    // todo\n  }\n  // Normalize option `escape`\n  if (options.escape === undefined || options.escape === null) {\n    options.escape = '\"';\n  } else if (Buffer.isBuffer(options.escape)) {\n    options.escape = options.escape.toString();\n  } else if (typeof options.escape !== \"string\") {\n    return [\n      Error(\n        `Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`,\n      ),\n    ];\n  }\n  if (options.escape.length > 1) {\n    return [\n      Error(\n        `Invalid Option: escape must be one character, got ${options.escape.length} characters`,\n      ),\n    ];\n  }\n  // Normalize option `header`\n  if (options.header === undefined || options.header === null) {\n    options.header = false;\n  } else {\n    // todo\n  }\n  // Normalize option `columns`\n  const [errColumns, columns] = normalize_columns(options.columns);\n  if (errColumns !== undefined) return [errColumns];\n  options.columns = columns;\n  // Normalize option `quoted`\n  if (options.quoted === undefined || options.quoted === null) {\n    options.quoted = false;\n  } else {\n    // todo\n  }\n  // Normalize option `cast`\n  if (options.cast === undefined || options.cast === null) {\n    options.cast = {};\n  } else {\n    // todo\n  }\n  // Normalize option cast.bigint\n  if (options.cast.bigint === undefined || options.cast.bigint === null) {\n    // Cast boolean to string by default\n    options.cast.bigint = (value) => \"\" + value;\n  }\n  // Normalize option cast.boolean\n  if (options.cast.boolean === undefined || options.cast.boolean === null) {\n    // Cast boolean to string by default\n    options.cast.boolean = (value) => (value ? \"1\" : \"\");\n  }\n  // Normalize option cast.date\n  if (options.cast.date === undefined || options.cast.date === null) {\n    // Cast date to timestamp string by default\n    options.cast.date = (value) => \"\" + value.getTime();\n  }\n  // Normalize option cast.number\n  if (options.cast.number === undefined || options.cast.number === null) {\n    // Cast number to string using native casting by default\n    options.cast.number = (value) => \"\" + value;\n  }\n  // Normalize option cast.object\n  if (options.cast.object === undefined || options.cast.object === null) {\n    // Stringify object as JSON by default\n    options.cast.object = (value) => JSON.stringify(value);\n  }\n  // Normalize option cast.string\n  if (options.cast.string === undefined || options.cast.string === null) {\n    // Leave string untouched\n    options.cast.string = function (value) {\n      return value;\n    };\n  }\n  // Normalize option `on_record`\n  if (\n    options.on_record !== undefined &&\n    typeof options.on_record !== \"function\"\n  ) {\n    return [Error(`Invalid Option: \"on_record\" must be a function.`)];\n  }\n  // Normalize option `record_delimiter`\n  if (\n    options.record_delimiter === undefined ||\n    options.record_delimiter === null\n  ) {\n    options.record_delimiter = \"\\n\";\n  } else if (Buffer.isBuffer(options.record_delimiter)) {\n    options.record_delimiter = options.record_delimiter.toString();\n  } else if (typeof options.record_delimiter !== \"string\") {\n    return [\n      Error(\n        `Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`,\n      ),\n    ];\n  }\n  switch (options.record_delimiter) {\n    case \"unix\":\n      options.record_delimiter = \"\\n\";\n      break;\n    case \"mac\":\n      options.record_delimiter = \"\\r\";\n      break;\n    case \"windows\":\n      options.record_delimiter = \"\\r\\n\";\n      break;\n    case \"ascii\":\n      options.record_delimiter = \"\\u001e\";\n      break;\n    case \"unicode\":\n      options.record_delimiter = \"\\u2028\";\n      break;\n  }\n  return [undefined, options];\n};\n\nexport { normalize_options };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 808, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jose/.gemini/antigravity/scratch/ai-woo-uploader/node_modules/csv-stringify/lib/api/index.js"],"sourcesContent":["import { get } from \"../utils/get.js\";\nimport { is_object } from \"../utils/is_object.js\";\nimport { normalize_columns } from \"./normalize_columns.js\";\nimport { normalize_options } from \"./normalize_options.js\";\nconst bom_utf8 = Buffer.from([239, 187, 191]);\n\nconst stringifier = function (options, state, info) {\n  return {\n    options: options,\n    state: state,\n    info: info,\n    __transform: function (chunk, push) {\n      // Chunk validation\n      if (!Array.isArray(chunk) && typeof chunk !== \"object\") {\n        return Error(\n          `Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`,\n        );\n      }\n      // Detect columns from the first record\n      if (this.info.records === 0) {\n        if (Array.isArray(chunk)) {\n          if (\n            this.options.header === true &&\n            this.options.columns === undefined\n          ) {\n            return Error(\n              \"Undiscoverable Columns: header option requires column option or object records\",\n            );\n          }\n        } else if (this.options.columns === undefined) {\n          const [err, columns] = normalize_columns(Object.keys(chunk));\n          if (err) return;\n          this.options.columns = columns;\n        }\n      }\n      // Emit the header\n      if (this.info.records === 0) {\n        this.bom(push);\n        const err = this.headers(push);\n        if (err) return err;\n      }\n      // Emit and stringify the record if an object or an array\n      try {\n        // this.emit('record', chunk, this.info.records);\n        if (this.options.on_record) {\n          this.options.on_record(chunk, this.info.records);\n        }\n      } catch (err) {\n        return err;\n      }\n      // Convert the record into a string\n      let err, chunk_string;\n      if (this.options.eof) {\n        [err, chunk_string] = this.stringify(chunk);\n        if (err) return err;\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          chunk_string = chunk_string + this.options.record_delimiter;\n        }\n      } else {\n        [err, chunk_string] = this.stringify(chunk);\n        if (err) return err;\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          if (this.options.header || this.info.records) {\n            chunk_string = this.options.record_delimiter + chunk_string;\n          }\n        }\n      }\n      // Emit the csv\n      this.info.records++;\n      push(chunk_string);\n    },\n    stringify: function (chunk, chunkIsHeader = false) {\n      if (typeof chunk !== \"object\") {\n        return [undefined, chunk];\n      }\n      const { columns } = this.options;\n      const record = [];\n      // Record is an array\n      if (Array.isArray(chunk)) {\n        // We are getting an array but the user has specified output columns. In\n        // this case, we respect the columns indexes\n        if (columns) {\n          chunk.splice(columns.length);\n        }\n        // Cast record elements\n        for (let i = 0; i < chunk.length; i++) {\n          const field = chunk[i];\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: i,\n            records: this.info.records,\n            header: chunkIsHeader,\n          });\n          if (err) return [err];\n          record[i] = [value, field];\n        }\n        // Record is a literal object\n        // `columns` is always defined: it is either provided or discovered.\n      } else {\n        for (let i = 0; i < columns.length; i++) {\n          const field = get(chunk, columns[i].key);\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: columns[i].key,\n            records: this.info.records,\n            header: chunkIsHeader,\n          });\n          if (err) return [err];\n          record[i] = [value, field];\n        }\n      }\n      let csvrecord = \"\";\n      for (let i = 0; i < record.length; i++) {\n        let options, err;\n\n        let [value, field] = record[i];\n        if (typeof value === \"string\") {\n          options = this.options;\n        } else if (is_object(value)) {\n          options = value;\n          value = options.value;\n          delete options.value;\n          if (\n            typeof value !== \"string\" &&\n            value !== undefined &&\n            value !== null\n          ) {\n            if (err)\n              return [\n                Error(\n                  `Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`,\n                ),\n              ];\n          }\n          options = { ...this.options, ...options };\n          [err, options] = normalize_options(options);\n          if (err !== undefined) {\n            return [err];\n          }\n        } else if (value === undefined || value === null) {\n          options = this.options;\n        } else {\n          return [\n            Error(\n              `Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`,\n            ),\n          ];\n        }\n        const {\n          delimiter,\n          escape,\n          quote,\n          quoted,\n          quoted_empty,\n          quoted_string,\n          quoted_match,\n          record_delimiter,\n          escape_formulas,\n        } = options;\n        if (\"\" === value && \"\" === field) {\n          let quotedMatch =\n            quoted_match &&\n            quoted_match.filter((quoted_match) => {\n              if (typeof quoted_match === \"string\") {\n                return value.indexOf(quoted_match) !== -1;\n              } else {\n                return quoted_match.test(value);\n              }\n            });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          const shouldQuote =\n            quotedMatch ||\n            true === quoted_empty ||\n            (true === quoted_string && false !== quoted_empty);\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        } else if (value) {\n          if (typeof value !== \"string\") {\n            return [\n              Error(\n                `Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`,\n              ),\n            ];\n          }\n          const containsdelimiter =\n            delimiter.length && value.indexOf(delimiter) >= 0;\n          const containsQuote = quote !== \"\" && value.indexOf(quote) >= 0;\n          const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n          const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n          const quotedString = quoted_string && typeof field === \"string\";\n          let quotedMatch =\n            quoted_match &&\n            quoted_match.filter((quoted_match) => {\n              if (typeof quoted_match === \"string\") {\n                return value.indexOf(quoted_match) !== -1;\n              } else {\n                return quoted_match.test(value);\n              }\n            });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          // See https://github.com/adaltas/node-csv/pull/387\n          // More about CSV injection or formula injection, when websites embed\n          // untrusted input inside CSV files:\n          // https://owasp.org/www-community/attacks/CSV_Injection\n          // http://georgemauer.net/2017/10/07/csv-injection.html\n          // Apple Numbers unicode normalization is empirical from testing\n          if (escape_formulas) {\n            switch (value[0]) {\n              case \"=\":\n              case \"+\":\n              case \"-\":\n              case \"@\":\n              case \"\\t\":\n              case \"\\r\":\n              case \"\\uFF1D\": // Unicode '='\n              case \"\\uFF0B\": // Unicode '+'\n              case \"\\uFF0D\": // Unicode '-'\n              case \"\\uFF20\": // Unicode '@'\n                value = `'${value}`;\n                break;\n            }\n          }\n          const shouldQuote =\n            containsQuote === true ||\n            containsdelimiter ||\n            containsRecordDelimiter ||\n            quoted ||\n            quotedString ||\n            quotedMatch;\n          if (shouldQuote === true && containsEscape === true) {\n            const regexp =\n              escape === \"\\\\\"\n                ? new RegExp(escape + escape, \"g\")\n                : new RegExp(escape, \"g\");\n            value = value.replace(regexp, escape + escape);\n          }\n          if (containsQuote === true) {\n            const regexp = new RegExp(quote, \"g\");\n            value = value.replace(regexp, escape + quote);\n          }\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        } else if (\n          quoted_empty === true ||\n          (field === \"\" && quoted_string === true && quoted_empty !== false)\n        ) {\n          csvrecord += quote + quote;\n        }\n        if (i !== record.length - 1) {\n          csvrecord += delimiter;\n        }\n      }\n      return [undefined, csvrecord];\n    },\n    bom: function (push) {\n      if (this.options.bom !== true) {\n        return;\n      }\n      push(bom_utf8);\n    },\n    headers: function (push) {\n      if (this.options.header === false) {\n        return;\n      }\n      if (this.options.columns === undefined) {\n        return;\n      }\n      let err;\n      let headers = this.options.columns.map((column) => column.header);\n      if (this.options.eof) {\n        [err, headers] = this.stringify(headers, true);\n        headers += this.options.record_delimiter;\n      } else {\n        [err, headers] = this.stringify(headers);\n      }\n      if (err) return err;\n      push(headers);\n    },\n    __cast: function (value, context) {\n      const type = typeof value;\n      try {\n        if (type === \"string\") {\n          // Fine for 99% of the cases\n          return [undefined, this.options.cast.string(value, context)];\n        } else if (type === \"bigint\") {\n          return [undefined, this.options.cast.bigint(value, context)];\n        } else if (type === \"number\") {\n          return [undefined, this.options.cast.number(value, context)];\n        } else if (type === \"boolean\") {\n          return [undefined, this.options.cast.boolean(value, context)];\n        } else if (value instanceof Date) {\n          return [undefined, this.options.cast.date(value, context)];\n        } else if (type === \"object\" && value !== null) {\n          return [undefined, this.options.cast.object(value, context)];\n        } else {\n          return [undefined, value, value];\n        }\n      } catch (err) {\n        return [err];\n      }\n    },\n  };\n};\n\nexport { stringifier };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1131, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jose/.gemini/antigravity/scratch/ai-woo-uploader/node_modules/csv-stringify/lib/sync.js"],"sourcesContent":["import { stringifier } from \"./api/index.js\";\nimport { normalize_options } from \"./api/normalize_options.js\";\n\nconst stringify = function (records, opts = {}) {\n  const data = [];\n  const [err, options] = normalize_options(opts);\n  if (err !== undefined) throw err;\n  const state = {\n    stop: false,\n  };\n  // Information\n  const info = {\n    records: 0,\n  };\n  const api = stringifier(options, state, info);\n  for (const record of records) {\n    const err = api.__transform(record, function (record) {\n      data.push(record);\n    });\n    if (err !== undefined) throw err;\n  }\n  if (data.length === 0) {\n    api.bom((d) => {\n      data.push(d);\n    });\n    const err = api.headers((headers) => {\n      data.push(headers);\n    });\n    if (err !== undefined) throw err;\n  }\n  return data.join(\"\");\n};\n\nexport { stringify };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,YAAY,SAAU,OAAO,EAAE,OAAO,CAAC,CAAC;IAC5C,MAAM,OAAO,EAAE;IACf,MAAM,CAAC,KAAK,QAAQ,GAAG,IAAA,0LAAiB,EAAC;IACzC,IAAI,QAAQ,WAAW,MAAM;IAC7B,MAAM,QAAQ;QACZ,MAAM;IACR;IACA,cAAc;IACd,MAAM,OAAO;QACX,SAAS;IACX;IACA,MAAM,MAAM,IAAA,wKAAW,EAAC,SAAS,OAAO;IACxC,KAAK,MAAM,UAAU,QAAS;QAC5B,MAAM,MAAM,IAAI,WAAW,CAAC,QAAQ,SAAU,MAAM;YAClD,KAAK,IAAI,CAAC;QACZ;QACA,IAAI,QAAQ,WAAW,MAAM;IAC/B;IACA,IAAI,KAAK,MAAM,KAAK,GAAG;QACrB,IAAI,GAAG,CAAC,CAAC;YACP,KAAK,IAAI,CAAC;QACZ;QACA,MAAM,MAAM,IAAI,OAAO,CAAC,CAAC;YACvB,KAAK,IAAI,CAAC;QACZ;QACA,IAAI,QAAQ,WAAW,MAAM;IAC/B;IACA,OAAO,KAAK,IAAI,CAAC;AACnB","ignoreList":[0]}}]
}