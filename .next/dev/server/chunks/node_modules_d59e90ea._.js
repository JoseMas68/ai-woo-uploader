module.exports = [
"[project]/node_modules/dotenv/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"dotenv","version":"17.2.3","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"homepage":"https://github.com/motdotla/dotenv#readme","funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}});}),
"[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const packageJson = __turbopack_context__.r("[project]/node_modules/dotenv/package.json (json)");
const version = packageJson.version;
// Array of tips to display randomly
const TIPS = [
    'üîê encrypt with Dotenvx: https://dotenvx.com',
    'üîê prevent committing .env to code: https://dotenvx.com/precommit',
    'üîê prevent building .env in docker: https://dotenvx.com/prebuild',
    'üì° add observability to secrets: https://dotenvx.com/ops',
    'üë• sync secrets across teammates & machines: https://dotenvx.com/ops',
    'üóÇÔ∏è backup and recover secrets: https://dotenvx.com/ops',
    '‚úÖ audit secrets and track compliance: https://dotenvx.com/ops',
    'üîÑ add secrets lifecycle management: https://dotenvx.com/ops',
    'üîë add access controls to secrets: https://dotenvx.com/ops',
    'üõ†Ô∏è  run anywhere with `dotenvx run -- yourcommand`',
    '‚öôÔ∏è  specify custom .env file path with { path: \'/custom/path/.env\' }',
    '‚öôÔ∏è  enable debug logging with { debug: true }',
    '‚öôÔ∏è  override existing env vars with { override: true }',
    '‚öôÔ∏è  suppress all logs with { quiet: true }',
    '‚öôÔ∏è  write to custom object with { processEnv: myObject }',
    '‚öôÔ∏è  load multiple .env files with { path: [\'.env.local\', \'.env\'] }'
];
// Get a random tip from the tips array
function _getRandomTip() {
    return TIPS[Math.floor(Math.random() * TIPS.length)];
}
function parseBoolean(value) {
    if (typeof value === 'string') {
        return ![
            'false',
            '0',
            'no',
            'off',
            ''
        ].includes(value.toLowerCase());
    }
    return Boolean(value);
}
function supportsAnsi() {
    return process.stdout.isTTY // && process.env.TERM !== 'dumb'
    ;
}
function dim(text) {
    return supportsAnsi() ? `\x1b[2m${text}\x1b[0m` : text;
}
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
// Parse src into an Object
function parse(src) {
    const obj = {};
    // Convert buffer to string
    let lines = src.toString();
    // Convert line breaks to same format
    lines = lines.replace(/\r\n?/mg, '\n');
    let match;
    while((match = LINE.exec(lines)) != null){
        const key = match[1];
        // Default undefined or null to empty string
        let value = match[2] || '';
        // Remove whitespace
        value = value.trim();
        // Check if double quoted
        const maybeQuote = value[0];
        // Remove surrounding quotes
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');
        // Expand newlines if double quoted
        if (maybeQuote === '"') {
            value = value.replace(/\\n/g, '\n');
            value = value.replace(/\\r/g, '\r');
        }
        // Add to object
        obj[key] = value;
    }
    return obj;
}
function _parseVault(options) {
    options = options || {};
    const vaultPath = _vaultPath(options);
    options.path = vaultPath; // parse .env.vault
    const result = DotenvModule.configDotenv(options);
    if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = 'MISSING_DATA';
        throw err;
    }
    // handle scenario for comma separated keys - for use with key rotation
    // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
    const keys = _dotenvKey(options).split(',');
    const length = keys.length;
    let decrypted;
    for(let i = 0; i < length; i++){
        try {
            // Get full key
            const key = keys[i].trim();
            // Get instructions for decrypt
            const attrs = _instructions(result, key);
            // Decrypt
            decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
            break;
        } catch (error) {
            // last key
            if (i + 1 >= length) {
                throw error;
            }
        // try next key
        }
    }
    // Parse decrypted .env string
    return DotenvModule.parse(decrypted);
}
function _warn(message) {
    console.error(`[dotenv@${version}][WARN] ${message}`);
}
function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
}
function _log(message) {
    console.log(`[dotenv@${version}] ${message}`);
}
function _dotenvKey(options) {
    // prioritize developer directly setting options.DOTENV_KEY
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
    }
    // secondary infra already contains a DOTENV_KEY environment variable
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
    }
    // fallback to empty string
    return '';
}
function _instructions(result, dotenvKey) {
    // Parse DOTENV_KEY. Format is a URI
    let uri;
    try {
        uri = new URL(dotenvKey);
    } catch (error) {
        if (error.code === 'ERR_INVALID_URL') {
            const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');
            err.code = 'INVALID_DOTENV_KEY';
            throw err;
        }
        throw error;
    }
    // Get decrypt key
    const key = uri.password;
    if (!key) {
        const err = new Error('INVALID_DOTENV_KEY: Missing key part');
        err.code = 'INVALID_DOTENV_KEY';
        throw err;
    }
    // Get environment
    const environment = uri.searchParams.get('environment');
    if (!environment) {
        const err = new Error('INVALID_DOTENV_KEY: Missing environment part');
        err.code = 'INVALID_DOTENV_KEY';
        throw err;
    }
    // Get ciphertext payload
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION
    ;
    if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';
        throw err;
    }
    return {
        ciphertext,
        key
    };
}
function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
            for (const filepath of options.path){
                if (fs.existsSync(filepath)) {
                    possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;
                }
            }
        } else {
            possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;
        }
    } else {
        possibleVaultPath = path.resolve(process.cwd(), '.env.vault');
    }
    if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
    }
    return null;
}
function _resolveHome(envPath) {
    return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options) {
    const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options && options.debug);
    const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (debug || !quiet) {
        _log('Loading env from encrypted .env.vault');
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
        processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return {
        parsed
    };
}
function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), '.env');
    let encoding = 'utf8';
    let processEnv = process.env;
    if (options && options.processEnv != null) {
        processEnv = options.processEnv;
    }
    let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options && options.debug);
    let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (options && options.encoding) {
        encoding = options.encoding;
    } else {
        if (debug) {
            _debug('No encoding is specified. UTF-8 is used by default');
        }
    }
    let optionPaths = [
        dotenvPath
    ] // default, look for .env
    ;
    if (options && options.path) {
        if (!Array.isArray(options.path)) {
            optionPaths = [
                _resolveHome(options.path)
            ];
        } else {
            optionPaths = []; // reset default
            for (const filepath of options.path){
                optionPaths.push(_resolveHome(filepath));
            }
        }
    }
    // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
    // parsed data, we will combine it with process.env (or options.processEnv if provided).
    let lastError;
    const parsedAll = {};
    for (const path of optionPaths){
        try {
            // Specifying an encoding returns a string instead of a buffer
            const parsed = DotenvModule.parse(fs.readFileSync(path, {
                encoding
            }));
            DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
            if (debug) {
                _debug(`Failed to load ${path} ${e.message}`);
            }
            lastError = e;
        }
    }
    const populated = DotenvModule.populate(processEnv, parsedAll, options);
    // handle user settings DOTENV_CONFIG_ options inside .env file(s)
    debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);
    quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
    if (debug || !quiet) {
        const keysCount = Object.keys(populated).length;
        const shortPaths = [];
        for (const filePath of optionPaths){
            try {
                const relative = path.relative(process.cwd(), filePath);
                shortPaths.push(relative);
            } catch (e) {
                if (debug) {
                    _debug(`Failed to load ${filePath} ${e.message}`);
                }
                lastError = e;
            }
        }
        _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`-- tip: ${_getRandomTip()}`)}`);
    }
    if (lastError) {
        return {
            parsed: parsedAll,
            error: lastError
        };
    } else {
        return {
            parsed: parsedAll
        };
    }
}
// Populates process.env from .env file
function config(options) {
    // fallback to original dotenv if DOTENV_KEY is not set
    if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    // dotenvKey exists but .env.vault file does not exist
    if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
}
function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), 'hex');
    let ciphertext = Buffer.from(encrypted, 'base64');
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
        const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === 'Invalid key length';
        const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';
        if (isRange || invalidKeyLength) {
            const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
            err.code = 'INVALID_DOTENV_KEY';
            throw err;
        } else if (decryptionFailed) {
            const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
            err.code = 'DECRYPTION_FAILED';
            throw err;
        } else {
            throw error;
        }
    }
}
// Populate process.env with parsed values
function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    const populated = {};
    if (typeof parsed !== 'object') {
        const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
        err.code = 'OBJECT_REQUIRED';
        throw err;
    }
    // Set process.env
    for (const key of Object.keys(parsed)){
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
            if (override === true) {
                processEnv[key] = parsed[key];
                populated[key] = parsed[key];
            }
            if (debug) {
                if (override === true) {
                    _debug(`"${key}" is already defined and WAS overwritten`);
                } else {
                    _debug(`"${key}" is already defined and was NOT overwritten`);
                }
            }
        } else {
            processEnv[key] = parsed[key];
            populated[key] = parsed[key];
        }
    }
    return populated;
}
const DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse,
    populate
};
module.exports.configDotenv = DotenvModule.configDotenv;
module.exports._configVault = DotenvModule._configVault;
module.exports._parseVault = DotenvModule._parseVault;
module.exports.config = DotenvModule.config;
module.exports.decrypt = DotenvModule.decrypt;
module.exports.parse = DotenvModule.parse;
module.exports.populate = DotenvModule.populate;
module.exports = DotenvModule;
}),
"[project]/node_modules/csv-stringify/lib/utils/get.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Lodash implementation of `get`
__turbopack_context__.s([
    "get",
    ()=>get
]);
const charCodeOfDot = ".".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(// Match anything that isn't a dot or bracket.
"[^.[\\]]+" + "|" + // Or match property names within brackets.
"\\[(?:" + // Match a non-string expression.
"([^\"'][^[]*)" + "|" + // Or match strings (supports escaping characters).
"([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2" + ")\\]" + "|" + // Or match "" as the space between consecutive dots or empty brackets.
"(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");
const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const getTag = function(value) {
    // if (!value) value === undefined ? "[object Undefined]" : "[object Null]";
    return Object.prototype.toString.call(value);
};
const isSymbol = function(value) {
    const type = typeof value;
    return type === "symbol" || type === "object" && value && getTag(value) === "[object Symbol]";
};
const isKey = function(value, object) {
    if (Array.isArray(value)) {
        return false;
    }
    const type = typeof value;
    if (type === "number" || type === "symbol" || type === "boolean" || !value || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
};
const stringToPath = function(string) {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("");
    }
    string.replace(rePropName, function(match, expression, quote, subString) {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, "$1");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);
    });
    return result;
};
const castPath = function(value, object) {
    if (Array.isArray(value)) {
        return value;
    } else {
        return isKey(value, object) ? [
            value
        ] : stringToPath(value);
    }
};
const toKey = function(value) {
    if (typeof value === "string" || isSymbol(value)) return value;
    const result = `${value}`;
    // eslint-disable-next-line
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
};
const get = function(object, path) {
    path = castPath(path, object);
    let index = 0;
    const length = path.length;
    while(object != null && index < length){
        object = object[toKey(path[index++])];
    }
    return index && index === length ? object : undefined;
};
;
}),
"[project]/node_modules/csv-stringify/lib/utils/is_object.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "is_object",
    ()=>is_object
]);
const is_object = function(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};
;
}),
"[project]/node_modules/csv-stringify/lib/api/normalize_columns.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalize_columns",
    ()=>normalize_columns
]);
const normalize_columns = function(columns) {
    if (columns === undefined || columns === null) {
        return [
            undefined,
            undefined
        ];
    }
    if (typeof columns !== "object") {
        return [
            Error('Invalid option "columns": expect an array or an object')
        ];
    }
    if (!Array.isArray(columns)) {
        const newcolumns = [];
        for(const k in columns){
            newcolumns.push({
                key: k,
                header: columns[k]
            });
        }
        columns = newcolumns;
    } else {
        const newcolumns = [];
        for (const column of columns){
            if (typeof column === "string") {
                newcolumns.push({
                    key: column,
                    header: column
                });
            } else if (typeof column === "object" && column !== null && !Array.isArray(column)) {
                if (!column.key) {
                    return [
                        Error('Invalid column definition: property "key" is required')
                    ];
                }
                if (column.header === undefined) {
                    column.header = column.key;
                }
                newcolumns.push(column);
            } else {
                return [
                    Error("Invalid column definition: expect a string or an object")
                ];
            }
        }
        columns = newcolumns;
    }
    return [
        undefined,
        columns
    ];
};
;
}),
"[project]/node_modules/csv-stringify/lib/api/CsvError.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CsvError",
    ()=>CsvError
]);
class CsvError extends Error {
    constructor(code, message, ...contexts){
        if (Array.isArray(message)) message = message.join(" ");
        super(message);
        if (Error.captureStackTrace !== undefined) {
            Error.captureStackTrace(this, CsvError);
        }
        this.code = code;
        for (const context of contexts){
            for(const key in context){
                const value = context[key];
                this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));
            }
        }
    }
}
;
}),
"[project]/node_modules/csv-stringify/lib/utils/underscore.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "underscore",
    ()=>underscore
]);
const underscore = function(str) {
    return str.replace(/([A-Z])/g, function(_, match) {
        return "_" + match.toLowerCase();
    });
};
;
}),
"[project]/node_modules/csv-stringify/lib/api/normalize_options.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalize_options",
    ()=>normalize_options
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-stringify/lib/api/CsvError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_columns$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-stringify/lib/api/normalize_columns.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$underscore$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-stringify/lib/utils/underscore.js [app-route] (ecmascript)");
;
;
;
const normalize_options = function(opts) {
    const options = {};
    // Merge with user options
    for(const opt in opts){
        options[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$underscore$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["underscore"])(opt)] = opts[opt];
    }
    // Normalize option `bom`
    if (options.bom === undefined || options.bom === null || options.bom === false) {
        options.bom = false;
    } else if (options.bom !== true) {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_OPTION_BOOLEAN_INVALID_TYPE", [
                "option `bom` is optional and must be a boolean value,",
                `got ${JSON.stringify(options.bom)}`
            ])
        ];
    }
    // Normalize option `delimiter`
    if (options.delimiter === undefined || options.delimiter === null) {
        options.delimiter = ",";
    } else if (Buffer.isBuffer(options.delimiter)) {
        options.delimiter = options.delimiter.toString();
    } else if (typeof options.delimiter !== "string") {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_OPTION_DELIMITER_INVALID_TYPE", [
                "option `delimiter` must be a buffer or a string,",
                `got ${JSON.stringify(options.delimiter)}`
            ])
        ];
    }
    // Normalize option `quote`
    if (options.quote === undefined || options.quote === null) {
        options.quote = '"';
    } else if (options.quote === true) {
        options.quote = '"';
    } else if (options.quote === false) {
        options.quote = "";
    } else if (Buffer.isBuffer(options.quote)) {
        options.quote = options.quote.toString();
    } else if (typeof options.quote !== "string") {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_OPTION_QUOTE_INVALID_TYPE", [
                "option `quote` must be a boolean, a buffer or a string,",
                `got ${JSON.stringify(options.quote)}`
            ])
        ];
    }
    // Normalize option `quoted`
    if (options.quoted === undefined || options.quoted === null) {
        options.quoted = false;
    } else {
    // todo
    }
    // Normalize option `escape_formulas`
    if (options.escape_formulas === undefined || options.escape_formulas === null) {
        options.escape_formulas = false;
    } else if (typeof options.escape_formulas !== "boolean") {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE", [
                "option `escape_formulas` must be a boolean,",
                `got ${JSON.stringify(options.escape_formulas)}`
            ])
        ];
    }
    // Normalize option `quoted_empty`
    if (options.quoted_empty === undefined || options.quoted_empty === null) {
        options.quoted_empty = undefined;
    } else {
    // todo
    }
    // Normalize option `quoted_match`
    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {
        options.quoted_match = null;
    } else if (!Array.isArray(options.quoted_match)) {
        options.quoted_match = [
            options.quoted_match
        ];
    }
    if (options.quoted_match) {
        for (const quoted_match of options.quoted_match){
            const isString = typeof quoted_match === "string";
            const isRegExp = quoted_match instanceof RegExp;
            if (!isString && !isRegExp) {
                return [
                    Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)
                ];
            }
        }
    }
    // Normalize option `quoted_string`
    if (options.quoted_string === undefined || options.quoted_string === null) {
        options.quoted_string = false;
    } else {
    // todo
    }
    // Normalize option `eof`
    if (options.eof === undefined || options.eof === null) {
        options.eof = true;
    } else {
    // todo
    }
    // Normalize option `escape`
    if (options.escape === undefined || options.escape === null) {
        options.escape = '"';
    } else if (Buffer.isBuffer(options.escape)) {
        options.escape = options.escape.toString();
    } else if (typeof options.escape !== "string") {
        return [
            Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)
        ];
    }
    if (options.escape.length > 1) {
        return [
            Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)
        ];
    }
    // Normalize option `header`
    if (options.header === undefined || options.header === null) {
        options.header = false;
    } else {
    // todo
    }
    // Normalize option `columns`
    const [errColumns, columns] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_columns$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_columns"])(options.columns);
    if (errColumns !== undefined) return [
        errColumns
    ];
    options.columns = columns;
    // Normalize option `quoted`
    if (options.quoted === undefined || options.quoted === null) {
        options.quoted = false;
    } else {
    // todo
    }
    // Normalize option `cast`
    if (options.cast === undefined || options.cast === null) {
        options.cast = {};
    } else {
    // todo
    }
    // Normalize option cast.bigint
    if (options.cast.bigint === undefined || options.cast.bigint === null) {
        // Cast boolean to string by default
        options.cast.bigint = (value)=>"" + value;
    }
    // Normalize option cast.boolean
    if (options.cast.boolean === undefined || options.cast.boolean === null) {
        // Cast boolean to string by default
        options.cast.boolean = (value)=>value ? "1" : "";
    }
    // Normalize option cast.date
    if (options.cast.date === undefined || options.cast.date === null) {
        // Cast date to timestamp string by default
        options.cast.date = (value)=>"" + value.getTime();
    }
    // Normalize option cast.number
    if (options.cast.number === undefined || options.cast.number === null) {
        // Cast number to string using native casting by default
        options.cast.number = (value)=>"" + value;
    }
    // Normalize option cast.object
    if (options.cast.object === undefined || options.cast.object === null) {
        // Stringify object as JSON by default
        options.cast.object = (value)=>JSON.stringify(value);
    }
    // Normalize option cast.string
    if (options.cast.string === undefined || options.cast.string === null) {
        // Leave string untouched
        options.cast.string = function(value) {
            return value;
        };
    }
    // Normalize option `on_record`
    if (options.on_record !== undefined && typeof options.on_record !== "function") {
        return [
            Error(`Invalid Option: "on_record" must be a function.`)
        ];
    }
    // Normalize option `record_delimiter`
    if (options.record_delimiter === undefined || options.record_delimiter === null) {
        options.record_delimiter = "\n";
    } else if (Buffer.isBuffer(options.record_delimiter)) {
        options.record_delimiter = options.record_delimiter.toString();
    } else if (typeof options.record_delimiter !== "string") {
        return [
            Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)
        ];
    }
    switch(options.record_delimiter){
        case "unix":
            options.record_delimiter = "\n";
            break;
        case "mac":
            options.record_delimiter = "\r";
            break;
        case "windows":
            options.record_delimiter = "\r\n";
            break;
        case "ascii":
            options.record_delimiter = "\u001e";
            break;
        case "unicode":
            options.record_delimiter = "\u2028";
            break;
    }
    return [
        undefined,
        options
    ];
};
;
}),
"[project]/node_modules/csv-stringify/lib/api/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "stringifier",
    ()=>stringifier
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-stringify/lib/utils/get.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-stringify/lib/utils/is_object.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_columns$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-stringify/lib/api/normalize_columns.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-stringify/lib/api/normalize_options.js [app-route] (ecmascript)");
;
;
;
;
const bom_utf8 = Buffer.from([
    239,
    187,
    191
]);
const stringifier = function(options, state, info) {
    return {
        options: options,
        state: state,
        info: info,
        __transform: function(chunk, push) {
            // Chunk validation
            if (!Array.isArray(chunk) && typeof chunk !== "object") {
                return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);
            }
            // Detect columns from the first record
            if (this.info.records === 0) {
                if (Array.isArray(chunk)) {
                    if (this.options.header === true && this.options.columns === undefined) {
                        return Error("Undiscoverable Columns: header option requires column option or object records");
                    }
                } else if (this.options.columns === undefined) {
                    const [err, columns] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_columns$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_columns"])(Object.keys(chunk));
                    if (err) return;
                    this.options.columns = columns;
                }
            }
            // Emit the header
            if (this.info.records === 0) {
                this.bom(push);
                const err = this.headers(push);
                if (err) return err;
            }
            // Emit and stringify the record if an object or an array
            try {
                // this.emit('record', chunk, this.info.records);
                if (this.options.on_record) {
                    this.options.on_record(chunk, this.info.records);
                }
            } catch (err) {
                return err;
            }
            // Convert the record into a string
            let err, chunk_string;
            if (this.options.eof) {
                [err, chunk_string] = this.stringify(chunk);
                if (err) return err;
                if (chunk_string === undefined) {
                    return;
                } else {
                    chunk_string = chunk_string + this.options.record_delimiter;
                }
            } else {
                [err, chunk_string] = this.stringify(chunk);
                if (err) return err;
                if (chunk_string === undefined) {
                    return;
                } else {
                    if (this.options.header || this.info.records) {
                        chunk_string = this.options.record_delimiter + chunk_string;
                    }
                }
            }
            // Emit the csv
            this.info.records++;
            push(chunk_string);
        },
        stringify: function(chunk, chunkIsHeader = false) {
            if (typeof chunk !== "object") {
                return [
                    undefined,
                    chunk
                ];
            }
            const { columns } = this.options;
            const record = [];
            // Record is an array
            if (Array.isArray(chunk)) {
                // We are getting an array but the user has specified output columns. In
                // this case, we respect the columns indexes
                if (columns) {
                    chunk.splice(columns.length);
                }
                // Cast record elements
                for(let i = 0; i < chunk.length; i++){
                    const field = chunk[i];
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: i,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err) return [
                        err
                    ];
                    record[i] = [
                        value,
                        field
                    ];
                }
            // Record is a literal object
            // `columns` is always defined: it is either provided or discovered.
            } else {
                for(let i = 0; i < columns.length; i++){
                    const field = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["get"])(chunk, columns[i].key);
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: columns[i].key,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err) return [
                        err
                    ];
                    record[i] = [
                        value,
                        field
                    ];
                }
            }
            let csvrecord = "";
            for(let i = 0; i < record.length; i++){
                let options, err;
                let [value, field] = record[i];
                if (typeof value === "string") {
                    options = this.options;
                } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["is_object"])(value)) {
                    options = value;
                    value = options.value;
                    delete options.value;
                    if (typeof value !== "string" && value !== undefined && value !== null) {
                        if (err) return [
                            Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)
                        ];
                    }
                    options = {
                        ...this.options,
                        ...options
                    };
                    [err, options] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_options"])(options);
                    if (err !== undefined) {
                        return [
                            err
                        ];
                    }
                } else if (value === undefined || value === null) {
                    options = this.options;
                } else {
                    return [
                        Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)
                    ];
                }
                const { delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas } = options;
                if ("" === value && "" === field) {
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{
                        if (typeof quoted_match === "string") {
                            return value.indexOf(quoted_match) !== -1;
                        } else {
                            return quoted_match.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                } else if (value) {
                    if (typeof value !== "string") {
                        return [
                            Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)
                        ];
                    }
                    const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;
                    const containsQuote = quote !== "" && value.indexOf(quote) >= 0;
                    const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;
                    const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;
                    const quotedString = quoted_string && typeof field === "string";
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{
                        if (typeof quoted_match === "string") {
                            return value.indexOf(quoted_match) !== -1;
                        } else {
                            return quoted_match.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    // See https://github.com/adaltas/node-csv/pull/387
                    // More about CSV injection or formula injection, when websites embed
                    // untrusted input inside CSV files:
                    // https://owasp.org/www-community/attacks/CSV_Injection
                    // http://georgemauer.net/2017/10/07/csv-injection.html
                    // Apple Numbers unicode normalization is empirical from testing
                    if (escape_formulas) {
                        switch(value[0]){
                            case "=":
                            case "+":
                            case "-":
                            case "@":
                            case "\t":
                            case "\r":
                            case "\uFF1D":
                            case "\uFF0B":
                            case "\uFF0D":
                            case "\uFF20":
                                value = `'${value}`;
                                break;
                        }
                    }
                    const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
                    if (shouldQuote === true && containsEscape === true) {
                        const regexp = escape === "\\" ? new RegExp(escape + escape, "g") : new RegExp(escape, "g");
                        value = value.replace(regexp, escape + escape);
                    }
                    if (containsQuote === true) {
                        const regexp = new RegExp(quote, "g");
                        value = value.replace(regexp, escape + quote);
                    }
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                } else if (quoted_empty === true || field === "" && quoted_string === true && quoted_empty !== false) {
                    csvrecord += quote + quote;
                }
                if (i !== record.length - 1) {
                    csvrecord += delimiter;
                }
            }
            return [
                undefined,
                csvrecord
            ];
        },
        bom: function(push) {
            if (this.options.bom !== true) {
                return;
            }
            push(bom_utf8);
        },
        headers: function(push) {
            if (this.options.header === false) {
                return;
            }
            if (this.options.columns === undefined) {
                return;
            }
            let err;
            let headers = this.options.columns.map((column)=>column.header);
            if (this.options.eof) {
                [err, headers] = this.stringify(headers, true);
                headers += this.options.record_delimiter;
            } else {
                [err, headers] = this.stringify(headers);
            }
            if (err) return err;
            push(headers);
        },
        __cast: function(value, context) {
            const type = typeof value;
            try {
                if (type === "string") {
                    // Fine for 99% of the cases
                    return [
                        undefined,
                        this.options.cast.string(value, context)
                    ];
                } else if (type === "bigint") {
                    return [
                        undefined,
                        this.options.cast.bigint(value, context)
                    ];
                } else if (type === "number") {
                    return [
                        undefined,
                        this.options.cast.number(value, context)
                    ];
                } else if (type === "boolean") {
                    return [
                        undefined,
                        this.options.cast.boolean(value, context)
                    ];
                } else if (value instanceof Date) {
                    return [
                        undefined,
                        this.options.cast.date(value, context)
                    ];
                } else if (type === "object" && value !== null) {
                    return [
                        undefined,
                        this.options.cast.object(value, context)
                    ];
                } else {
                    return [
                        undefined,
                        value,
                        value
                    ];
                }
            } catch (err) {
                return [
                    err
                ];
            }
        }
    };
};
;
}),
"[project]/node_modules/csv-stringify/lib/sync.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "stringify",
    ()=>stringify
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-stringify/lib/api/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-stringify/lib/api/normalize_options.js [app-route] (ecmascript)");
;
;
const stringify = function(records, opts = {}) {
    const data = [];
    const [err, options] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_options"])(opts);
    if (err !== undefined) throw err;
    const state = {
        stop: false
    };
    // Information
    const info = {
        records: 0
    };
    const api = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringifier"])(options, state, info);
    for (const record of records){
        const err = api.__transform(record, function(record) {
            data.push(record);
        });
        if (err !== undefined) throw err;
    }
    if (data.length === 0) {
        api.bom((d)=>{
            data.push(d);
        });
        const err = api.headers((headers)=>{
            data.push(headers);
        });
        if (err !== undefined) throw err;
    }
    return data.join("");
};
;
}),
];

//# sourceMappingURL=node_modules_d59e90ea._.js.map